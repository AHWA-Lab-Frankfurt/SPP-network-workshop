---
title: "How to get a rectangular data matrix into shape for network analysis"
author: "NG, JMPS"
date: "2 6 2021"
output: html_document
---
```{r libraries}
# this code contains all the libraries we need to use in this process. If they are not present, use install.packages("pacakge x") to get them.
library(tidyverse)
```

We will usually start our work with what is called a "rectangular" matrix of archaeological sites and finds. Rectangular in this case means that the row and column names are not identical. There are two ways of getting this data ready for network analysis. The first is a square matrix or adjacency matrix, the second is an edge list. We will here show the stepts to get both of these products in R.

```{r get data}

burkinasites.decor <- burkinasites %>% 
  column_to_rownames(var = "site_code") %>% 
  select(contains("decor")) %>% 
  replace(is.na(.),0) %>% 
  filter_all(any_vars(.), !0) 

burkinasites.decor

#removing plain and polished 
burkinasites.decor <- burkinasites.decor %>% 
  select(-decor_plain, -decor_poliert)
```

EIAGraves is a dataset of 52 different ceramic types in 6 large tombs and 10 broadly contemporaneous groups of tombs. To find out more, run this command
```{r find out about dataset}
help("EIAGraves")
```

# Adjacency Matrices

The first step for this data will be to tell R that the column "Type" contains the names of the rows. Then we will transpose the table, making the columns into the rows and vice-versa.
```{r column to row names}

```

What we want now is a so-called square matrix, where the rows and columns are the same...
based on co-presence


```{r co-presence (after Peeples 2017, http://mattpeeples.net/netstats.html)}
co.p <- function(x, thresh = 0.1) {
    # create matrix of proportions
    temp <- prop.table(as.matrix(x), 1)
    # define anything with greater than or equal to 0.1 as present (1)
    temp[temp >= thresh] <- 1
    # define all other cells as absent (0)
    temp[temp < 1] <- 0
    # matrix algebraic calculation to find co-occurence (%*% indicates matrix
    # multiplication)
    out <- temp %*% t(temp)
    return(out)
}

# run the function
gravesP <- co.p(burkinasites.decor, 0.6)
gravesP[lower.tri(gravesP, diag = TRUE)] <- 0
#Visually check the new table:
View(gravesP)
```


# Edge and node list format
It is sometimes easier to append and edit the network data when it is stored in two lists: an edge list, which has the connections and their attributes, and a node list, which stores the attributes of the nodes.
To create these lists only a edgelist is required. There are multiple ways to create an edgelist based on the way connections between nodes are calculated. In this example we use the copresence-matrix calculated before. 
```{r co-presence edgelist}

#an edgelist consists of all pairs of possible connections between graves 
#first we pick the elements that are linked (graves)
  edge.cop <- rownames(burkinasites.decor) %>%
  #combn gives out each possible pairing
    combn(m= 2) %>% 
  #as the data is wide we need to transpose it  
   t() %>% 
  #dataframe is the class that is normally used to create edgelists
    as.data.frame()
  
#to keep it simple we take the connection of each pair we already calculated with our copresence matrix
  edgeP <- co.p(burkinasites.decor, thresh = 0.6) 
  #we delete all redundant and selfrefering parts of the matrix
    edgeP[upper.tri(edgeP, diag = TRUE)] <- NA
  #  than we add it as to the dataframe with our grave pairs
    edge.cop$weight <- as.vector(edgeP) %>% 
      na.omit()
  
    #finally we delete all the pairs that share nothing 
  edge.cop <- edge.cop %>% 
   filter(weight > 0)
  
```


#network:
The adjacency matrix or the edgelist can now be used to create an network object. There are different packages that work with networks but a combination of "tidygraph"(clean& easy network data), "igraph" (network statistics) and "ggraph" (network visualisation) is the most convinient way. 
```{r creating network objects}
library(tidygraph)


#tidygraph::as_tbl_graph is a pretty powerfull function that can turn adjacency matrices and edgelists into network objects
netgravesP <- tidygraph::as_tbl_graph(gravesP)

#view doesnt work with network objects, but it isnt necessary to look at things anyway. an object can also just be looked at by calling its name as if it was a function
netgravesP
#we see that it consists of node data(the graves) and edge data (the connections based on copresence of pottery)


###now it is time for you to try something out yourself. transform the edgelist into a network object by using the same function as above on edge.cop
#write the command behind the arrow to save the network under the name netgravesEP
#if you dont know what to do you can look in the next chunk for the proper way
netgravesEP <- 
  
#lets look if it worked
  netgravesEP
```

#networkvisualization:
the network object itself doesnt give much information in the first place. But it is the basis to visualize the network. The visualisation can be used to get an overview on the structure of our network. 
```{r}
library(ggraph)
 
#the first command is the base of the plot containing data and the layout, here the data is our network graph based on the adjacency matrix
ggraph(gravesP, layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges 
    geom_edge_link() +
  #then the nodes plotted as points
  geom_node_point()+
 #to distinguish the graves we add a layer that contains there names. The aes(label = name) uses the names in the node list; the color="red" changes the color to make it easier to read. we will later show more ways to manipulate the layers to make more information vible
   geom_node_text(aes(label = name), color = "red")
  
 ##this is how an edgelist is transformed to a network with as_tbl_graph()
 netgravesEP <- tidygraph::as_tbl_graph(edge.cop) 

 #this time we use the network based on the edgelist.
  ggraph(netgravesEP, layout = "graphopt") +
  geom_edge_link() +
  geom_node_point()+
  geom_node_text(aes(label = name), color = "red")
  
  #what is the difference?
```

#networkvisualization2:
now that we know that the networks are (nearly) the same we will continue working only with netgravesP. we can extend the plot layers with aes() to make more sophisted plots that allow us to see more 
```{r}
netgravesP  %>% 
  activate(nodes) %>% 
  filter(!node_is_isolated()) %>% 
ggraph(layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the width of the edges is based on there weight. this way we can see which graves share more than just a single object
    geom_edge_link(aes(edge_width = weight), alpha = 0.5) +
  geom_node_point()+
  geom_node_text(aes(label = name))

netgravesP  %>% 
  activate(nodes) %>% 
  filter(!node_is_isolated()) %>% 
ggraph(layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the width of the edges is based on there weight. this way we can see which graves share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
  geom_node_point()+
  geom_node_text(aes(label = name))
```


```{r BR burkina}
sim.mat <- function(x) {
    # get names of sites
    names <- row.names(x)
    x <- na.omit(x)  # remove any rows with missing data
    x <- prop.table(as.matrix(x), 1)  # convert to row proportions
    rd <- dim(x)[1]
    # create an empty symmetric matrix of 0s
    results <- matrix(0, rd, rd)
    # the following dreaded double for loop goes through every cell in the
    # output data table and calculates the BR value as descried above
    for (s1 in 1:rd) {
        for (s2 in 1:rd) {
            x1Temp <- as.numeric(x[s1, ])
            x2Temp <- as.numeric(x[s2, ])
            results[s1, s2] <- 2 - (sum(abs(x1Temp - x2Temp)))
        }
    }
    row.names(results) <- names  # assign row names to output
    colnames(results) <- names  # assign column names to output
    results <- results/2  # rescale results between 0 and 1
    results <- round(results, 3)  # round results
    return(results)
}  # return the final output table

# Run the function defined above on our sample data
burkinaBR <- sim.mat(burkinasites.decor)
burkinaBR[lower.tri(burkinaBR, diag = TRUE)] <- 0
View(burkinaBR)

Brnet <- as_tbl_graph(burkinaBR)
Brnet

Brnet %>% activate(edges) %>% as.data.frame() %>% 
  ggplot(aes(x = weight))+
  geom_density()
  
#this suggests we need to get the weights between about 0.55 and 0.90 in order to only get the peak.
Brnet %>% 
  activate(edges) %>% 
  filter(weight>0.55) %>% 
  filter(weight<0.90) %>% 
  ggraph(layout = "stress")+
  geom_edge_link(aes(color = weight), alpha = 0.5) +
  geom_node_point()+
  geom_node_text(aes(label = name))
#still no good
Brnet %>% 
  activate(edges) %>% 
  filter(weight>0.9) %>% 
  activate(nodes) %>% 
  filter(!node_is_isolated()) %>% 
  ggraph(layout = "stress")+
  geom_edge_link(aes(color = weight), alpha = 0.5) +
  geom_node_point()+
  geom_node_text(aes(label = name))

```

