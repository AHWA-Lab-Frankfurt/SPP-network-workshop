---
title: "How to get a rectangular data matrix into shape for network analysis"
author: "NG, JMPS"
date: "2 6 2021"
output: html_document
---
```{r libraries}
# this code contains all the libraries we need to use in this process. If they are not present, use install.packages("pacakge x") to get them.
library(tidyverse)
```

We will usually start our work with what is called a "rectangular" matrix of archaeological sites and finds. Rectangular in this case means that the row and column names are not identical. There are two ways of getting this data ready for network analysis. The first is a square matrix or adjacency matrix, the second is an edge list. We will here show the stepts to get both of these products in R.

```{r get data}
# Here we get a dataset from the archdata repository. If you do not have this on your R installation yet, run:
# install.packages("archdata")
library(archdata) 
data(Michelsberg)
??archdata
#Visually check the data:
View(Michelsberg)
```

Michelsberg is a dataset of 52 different ceramic types in 6 large tombs and 10 broadly contemporaneous groups of tombs. To find out more, run this command
```{r find out about dataset}
help(Michelsberg)

```

# Adjacency Matrices

The first step for this data will be to tell R that the column "Type" contains the names of the rows. Then we will transpose the table, making the columns into the rows and vice-versa.
```{r column to row names}
Michelsberg.pot <- Michelsberg %>% 
  #for the start we only want one phase
  filter(mbk_phase == "III") %>% 
  #we select all columns that contain information on the amount of the different pottery types
  select(5:39)
```

What we want now is a so-called square matrix, where the rows and columns are the same...
based on co-presence


```{r co-presence (after Peeples 2017, http://mattpeeples.net/netstats.html)}
co.p <- function(x, thresh = 0.1) {
    # create matrix of proportions
    temp <- prop.table(as.matrix(x), 1)
    # define anything with greater than or equal to 0.1 as present (1)
    temp[temp >= thresh] <- 1
    # define all other cells as absent (0)
    temp[temp < 1] <- 0
    # matrix algebraic calculation to find co-occurence (%*% indicates matrix
    # multiplication)
    out <- temp %*% t(temp)
    return(out)
}

# run the function
potteryP <- co.p(Michelsberg.pot, 0.2)
potteryP[lower.tri(potteryP)] <- 0
#Visually check the new table:
View(potteryP)
```


# Edge and node list format
It is sometimes easier to append and edit the network data when it is stored in two lists: an edge list, which has the connections and their attributes, and a node list, which stores the attributes of the nodes.
To create these lists only a edgelist is required. There are multiple ways to create an edgelist based on the way connections between nodes are calculated. In this example we use the copresence-matrix calculated before. 
```{r co-presence edgelist}

#an edgelist consists of all pairs of possible connections between sites 
#first we pick the elements that are linked (sites)
  edge.cop <- rownames(Michelsberg.pot) %>%
  #combn gives out each possible pairing
    combn(m= 2) %>% 
  #as the data is wide we need to transpose it  
   t() %>% 
  #dataframe is the class that is normally used to create edgelists
    as.data.frame()
  
#to keep it simple we take the connection of each pair we already calculated with our copresence matrix
  edgeP <- co.p(Michelsberg.pot, thresh = 0.2) 
  #we delete all redundant and selfrefering parts of the matrix
   edgeP[upper.tri(edgeP, diag = TRUE)] <- NA
  #  than we add it as to the dataframe with our grave pairs
    edge.cop$weight <- as.vector(edgeP) %>% 
      na.omit()
  
    #finally we delete all the pairs that share nothing 
  edge.cop <- edge.cop %>% 
   filter(weight > 0)
  
```


#network:
The adjacency matrix or the edgelist can now be used to create an network object. There are different packages that work with networks but a combination of "tidygraph"(clean& easy network data), "igraph" (network statistics) and "ggraph" (network visualisation) is the most convinient way. 
```{r creating network objects}
library(tidygraph)


#tidygraph::as_tbl_graph is a pretty powerfull function that can turn adjacency matrices and edgelists into network objects
netpotteryP <- tidygraph::as_tbl_graph(potteryP)

#view doesnt work with network objects, but it isnt necessary to look at things anyway. an object can also just be looked at by calling its name as if it was a function
netpotteryP
#we see that it consists of node data(the pottery) and edge data (the connections based on copresence of pottery)


###now it is time for you to try something out yourself. transform the edgelist into a network object by using the same function as above on edge.cop
#write the command behind the arrow to save the network under the name netpotteryEP
#if you dont know what to do you can look in the next chunk for the proper way
netpotteryEP <- 
  
#lets look if it worked
  netpotteryEP
```

#networkvisualization:
the network object itself doesnt give much information in the first place. But it is the basis to visualize the network. The visualisation can be used to get an overview on the structure of our network. 
```{r}
library(ggraph)
 
#the first command is the base of the plot containing data and the layout, here the data is our network graph based on the adjacency matrix
ggraph(potteryP, layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges 
    geom_edge_link() +
  #then the nodes plotted as points
  geom_node_point()+
 #to distinguish the pottery we add a layer that contains there names. The aes(label = name) uses the names in the node list; the color="red" changes the color to make it easier to read. we will later show more ways to manipulate the layers to make more information vible
   geom_node_text(aes(label = name), color = "red")
  
 ##this is how an edgelist is transformed to a network with as_tbl_graph()
 netpotteryEP <- tidygraph::as_tbl_graph(edge.cop) 

 #this time we use the network based on the edgelist.
  ggraph(netpotteryEP, layout = "graphopt") +
  geom_edge_link() +
  geom_node_point()+
  geom_node_text(aes(label = name), color = "red")
  
  #what is the small difference?
```

#networkvisualization2:
now that we know that the networks are (nearly) the same we will continue working only with netpotteryP. we can extend the plot layers with aes() to make more sophisted plots that allow us to see more 
```{r}
 ggraph(potteryP, layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the width of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(edge_width = weight), alpha = 0.5) +
  geom_node_point()+
  geom_node_text(aes(label = name))

ggraph(potteryP, layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  geom_node_point()+
  geom_node_text(aes(label = name))
```

#working with the node list/visualisation3: maybe you want to compare the network to the landscape to check if geographic position plays a role for the connections. as we have coordinates in our data, but not yet in our network data. we need to add it first. The data can be added to the node list (if it is sitedata) or to the edgelist(if it would be data regarding the connection)
```{r nodelist and coords}
#we extract the coordinates for the sites of our period from the data
 coords <- Michelsberg %>% 
  #for the start we only want one phase
  filter(mbk_phase == "III") %>%
  select(x_utm32n, y_utm32n)
  
  
netpotteryP <- netpotteryP %>% 
  activate(nodes) %>% 
  mutate("lon" = coords$x_utm32n, "lat" = coords$y_utm32n)
  
netpotteryP
ggraph(netpotteryP, x = lon, y = lat) +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  geom_node_point()
#labels are removed to make it less fuzzy
```

```{r degree centrality}
library(igraph)
netpotteryP %>% 
  activate(nodes) %>% 
  mutate(deg = centrality_degree()) %>% 
  get.data.frame(what = c("vertices")) %>% 
  select(deg) %>% 
  arrange(-deg)

centrality_de
  
ggraph(netpotteryP, x = lon, y = lat) +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  geom_node_point(aes(size = centrality_degree(weights = weight)))
#labels are removed to make it less fuzzy

```
```{r higher thresh}
co.p(Michelsberg.pot, 0.25) %>% 
  as_tbl_graph() %>% 
  activate(nodes) %>% 
  mutate("lon" = coords$x_utm32n, "lat" = coords$y_utm32n) %>% 
 # filter(!node_is_isolated()) %>% 
  ggraph(x = lon, y = lat) +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  geom_node_point()


co.p(Michelsberg.pot, 0.25) %>% 
  as_tbl_graph() %>% 
  activate(nodes) %>% 
  filter(!node_is_isolated()) %>% 
  ggraph(layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  geom_node_point()+
  geom_node_text(aes(label = name))
```

