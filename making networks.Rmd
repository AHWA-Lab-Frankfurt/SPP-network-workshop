---
title: "Making Networks"
author: "Nikolas Gestrich, Juan-Marco Puerta-Schardt"
date: "6/3/2021"
output: html_document
---
```{r libraries, echo=FALSE, message=FALSE, warning=FALSE}
library(tidygraph)
```

```{r data import, echo=FALSE}
# We will load the data saved from the previous exercise
load(file = "mbk3mat.rda")
load(file = "mbk3edgelist.rda")
```

# Making a network from your data
The adjacency matrix or the edgelist can now be used to create an network object. There are many different R packages for network analysis by now. We will here work with `tidygraph` which provides a clean and easy way of manipulating the underlying data. It builds on `igraph` for the network statistics. Occasionally we will call `igraph` functions directly. For the visualisation, `tidygraph` integrates well with `ggraph`. For us this combination of packages is a good compromise between analytical power and usability. 

A network object can have various forms, but in the `tidygraph` format it consists of a nodelist and an edgelist. 
These network objects (often also called graph objects) are used for all further visualizations or analysis. More data can always be added to nodes and edges, or individual elements selected and further analysed, as we will show below. 

## Making a graph from an adjacency matrix

In order to turn our data into a graph, we use the `as_tbl_graph()` function that `tidygraph` provides. This function can read a large number of different formats into a tidygraph object.
```{r creating network objects from adjacency matrix}
mbk3Pnet <- tidygraph::as_tbl_graph(mbk3mat,           # use our Michelsberg matrix
                                    directed = FALSE)  # "directed = FALSE" makes sure that the function doesnt create a directed network

#Let's have a look at what we made. `View()` doesn't work with network objects, but it isn't necessary to look at objects anyway. An object can also just be looked at by calling its name as if it was a function.
mbk3Pnet
```
We can see that tidygraph creates an edgelist and a nodelist from our data. The sites are nodes and the edges are our calculated co-presence.

If we have an edgelist and nodelist, we can use the `tbl_graph()` function to combine both to an network object. The edgelist itself would be enough, but we already saved some extra information in the node list, so we pass it to the function too.
```{r make network object from edgelist}
#as_tbl_graph also works with node and edge lists. The function needs to be told which list to use for nodes and which list for edges.
mbk3EPnet <- tbl_graph(nodes = mbk3nodes, edges = mbk3edges, directed = FALSE)# "directed = FALSE" makes sure that the function doesnt create a directed network

#lets look if it worked
mbk3EPnet
```
The result from this is the same in the number of rows and edges.

We now have a network! This can be analyzed and visualized.

# Visualisation

In order to explore our network, it is often good to have a look at it first. Since the edge and node lists are essentially instructions for drawing a graph, this is what we will do in the first place. This explorative visualisation often allows us to generate first hypotheses.
The network plot is one of the biggest advantages of network analysis as it allows to show the connections of different sites and visualizes the relationship of past sites.
```{r explorative visualisation}
library(ggraph)

ggraph(mbk3Pnet,              # this first command is the base of the plot containing data and the layout, here the data is our network                                    graph based on the adjacency matrix
       layout = "stress") +  # this layout is a standard layout that tries to minimize the overlapping of edges by positioning the nodes                                   according to their position in the network.
            
    geom_edge_link() +  # with every layer (added with a +) we specify some new part of our network to the plot; first the edges 
    geom_node_point()+  # then the nodes plotted as points
    geom_node_text(aes(label = name), color = "red")   # to distinguish the sites we add a layer that contains their names. The aes(label =                                 name) uses the names in the node list; the color="red" changes the color to make it easier to read. We will                                 later show more ways to manipulate the layers to make more information visible.
  


 #Now we will visualise the network based on the edgelist.
  ggraph(mbk3EPnet, layout = "graphopt") +
    geom_edge_link() +
    geom_node_point()+
    geom_node_text(aes(label = id), color = "red")
```

What are the differences between the two networks?

#networkvisualization2:
The networks look very different. This comes from the different way they were built, especially because of the threshold in the co.p function (more about thresholds and filtering below). Both count the types each site shares. Because sites can share more than one type of pottery, the weight attribute of the edge shows how many types the sites share. This can be used to interpret the relationship between sites. 
The different weights of edges can be visualized via aesthetic attributes used for each layer. This way it shows the edge layer in more depth.
```{r}
 ggraph(mbk3Pnet, layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the width of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(edge_width = weight), alpha = 0.5) +
 #then the nodes plotted as points
  geom_node_point()+
#to distinguish the pottery we add a layer that contains there names. The aes(label = name) uses the names in the node list; the color="red" changes the color to make it easier to read. we will later show more ways to manipulate the layers to make more information vible
   geom_node_text(aes(label = name), color = "red")
  

ggraph(mbk3Pnet, layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
  #we can scale the color of the edges and a color palette based on the color for the lowest and the color for the highest value
scale_edge_color_continuous(low = "lightblue", high = "red") +
   #then the nodes plotted as points
  geom_node_point()+
 #to distinguish the pottery we add a layer that contains there names. The aes(label = name) uses the names in the node list; the color="red" changes the color to make it easier to read. we will later show more ways to manipulate the layers to make more information vible
   geom_node_text(aes(label = name), color = "red")
  


ggraph(mbk3EPnet, layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  #then the nodes plotted as points
  geom_node_point()+
 #to distinguish the pottery we add a layer that contains there names. The aes(label = name) uses the names in the node list; the color="red" changes the color to make it easier to read. we will later show more ways to manipulate the layers to make more information vible
  geom_node_text(aes(label = id), color = "red")


```

#filtering edges:
The nodes and edges a network contains can be filtered in multiple ways. With excluding every site that was not from MBK III, the nodes where already filtered. Of course this could have been also done based on other criteria like the type of site etc.. Often the non connected nodes are filtered to make the network more handy.
In our example network (mbk3EPnet) nearly every site is connected to every other site. Those networks are called "hairball networks" and often appear when the network is based on copresence (as 1 pottery type connects several sites to each other). As it is pretty difficult to analyze those graphs, it can be usefull to filter out small edges.
The strong interconnnectedness of the graph shows that nearly every site shares atleast 1-2 objects. This tells us that the MBK-sites of this period where all somewhat connected by a shared practice of pottery production (#maybe to early for this bold statement). If we are only interested in the sites that share multiple objects. We can filter out those sites that share less than that. For example: all sites that share only 1 object.
```{r}
#as the network based on edges is now clearer, but still like a "hairball", filtering the edges with the lowest weight can be used to give the network more structure.
#first we select the mbk3EPnet graph
mbk3EPnet %>% 
  #we select the edgelist
  activate(edges) %>% 
  #with filter we select all edges that have 2.5 or more weight
  filter(weight >= 2) %>% 
#add the new graph into the network
  ggraph( layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
 #then the nodes plotted as points
  geom_node_point()+
 #to distinguish the pottery we add a layer that contains there names. The aes(label = name) uses the names in the node list; the color="red" changes the color to make it easier to read. we will later show more ways to manipulate the layers to make more information vible
  geom_node_text(aes(label = id), color = "red")


mbk3EPnet %>% 
  #we select the edgelist
  activate(edges) %>% 
  #with filter we select all edges that have 2.5 or more weight
  filter(weight >= 4) %>% 
  #selecting the node list 
  activate(nodes) %>% 
  #because now some sites might not be connected to the network anymore, we will filter them out to keep the graph cleaner
  filter(!node_is_isolated()) %>% 
#add the new graph into the network
  ggraph( layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 4) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
 #then the nodes plotted as points
  geom_node_point()+
 #to distinguish the pottery we add a layer that contains there names. The aes(label = name) uses the names in the node list; the color="red" changes the color to make it easier to read. we will later show more ways to manipulate the layers to make more information vible
  geom_node_text(aes(label = id), color = "red")

#we save
```

While the method above filters out those connections that are below a wanted weight. The threshold part of the copresence matrix works a little bit different. We could also filter out the weakest edges here. But it was already filtered via the treshhold of 0.2. The threshold does not filter the edgelist instead it excludes all pottery that makes up less than a certain amount of the sites assemblage (threshold = 0.2 -> only pottery above 20% is taken into account). The threshold can be adjusted when using the co.p()-function. As we create a new copresence matrix every time we need to repeat the network creation process. 
The threshold needs to be archaeologically justified.Based on the research question it might be appropriate to ignore certain amounts of pottery. If, for example, the production or local consumption is studied, pottery types that appear in very small amounts might be ignored. If on the other hand the focus lies on trade, even rare and exotic pottery might be important for the analysis.
```{r higher thresh}
#we start again with the co.p() function but this time we go through the process in a faster way
co.p(mbk3, thresh = 0.25) %>% #calling the co.p function on mbk3, with a thresh of 0.25 (25%)
  as_tbl_graph() %>%  #creating a graph object with the adjacency matrix
  activate(nodes) %>% #picking the node list
  filter(!node_is_isolated()) %>% #filtering the node list
  ggraph(layout = "stress") + #now we plot the network with the new network object we crated
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  geom_node_point()+
  geom_node_text(aes(label = name))

```

In this part you can enter the threshold, to check how it affects the network. For example by using a tresh of 0.01 nearly all pottery types will be taken into account as they make up more than 1% of the sites assemblage.
```{r  higher threshhold test it yourself}
# behind "thresh =" you can enter a threshold you want to test. It is often useful to experiment with higher or lower thresholds to see how it affects the network. 
co.p(mbk3, thresh = 0.01) %>% 
  as_tbl_graph() %>% 
  activate(nodes) %>% 
  filter(!node_is_isolated()) %>% 
  ggraph(layout = "stress") +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  geom_node_point()+
  geom_node_text(aes(label = name))
```

#working with the node list/visualisation3: 
Maybe you want to compare the network to the landscape to check if geographic position plays a role for the connections. As we have coordinates in our data, but not yet in our network data. we need to add it first. The data can be added to the node list (if it is sitedata) or to the edgelist(if it would be data regarding the connection). 
```{r nodelist and coords}
#we extract the coordinates for the sites of our period from the data
 coords <- Michelsberg %>% 
  #for the start we only want one phase
  filter(mbk_phase == "III") %>%
 #we select the both columns containing the longitude and latitude
   select(x_utm32n, y_utm32n)
  
  
mbk3Pnet <- mbk3Pnet %>% 
  activate(nodes) %>% 
  mutate("lon" = coords$x_utm32n, "lat" = coords$y_utm32n)
  
mbk3Pnet

#To use coordinates, x = lon & y = lat are used instead of a layout based on the position inside a network
ggraph(mbk3Pnet, x = lon, y = lat) +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  geom_node_point()
#labels are removed to make it less fuzzy

#To use coordinates, x = lon & y = lat are used instead of a layout based on the position inside a network
ggraph(mbk3EPnet, x = lon, y = lat) +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
  geom_node_point()
#labels are removed to make it less fuzzy
```


#Centrality:
There are various statistical measurements for networks. Centrality scores are one of the most basic ones and give a good overview on the role of the node. There are many different ways to calculate centralities. They are all based on the connectedness of the node, the weight of the connections can be considered but does not need to be taken into account. 
The simplest centrality score is "degree centrality". It just counts the edges a node has. It is a relatively plain measure for the role of a node as it shows if it has many connections or only few. A node with a low "degree centrality" is probably a more isolated node on the margins of the network, while node with a high "degree centrality" is well connected and in a more central position. As the connections in archeological data are often based on similar artifacts, "degree centrality" indicates how similar the assemblage of a site is to others in the network.
If the "degree centrality" is weighted, it is the sum of the weight of the edges a node has. Therefore it not only shows how many connections a node has but also how strong they are. This often helps to get a more distinctive view on its role in the network.
The centrality values of sites can be added to the node list but the function can be also called as an aesthetic of the plot.
```{r degree centrality}
library(igraph)
mbk3EPnet %>% 
 #activating the node list to add the degree centrality score there
   activate(nodes) %>% 
  #adding the column deg to the node list
  mutate(deg = centrality_degree()) %>% 
  #getting only the node list as a dataframe
  igraph::get.data.frame(what = c("vertices")) %>% 
  #selecting deg as a shown column
  select(deg) %>% 
  #arranging it descending
  arrange(-deg)


  ggraph(mbk3EPnet, layout = "stress") +
 geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
 #the function centtrality_degree() can be called directly as an attribute that will be visualized
   geom_node_point(aes(size = centrality_degree(weights = weight)))+
#labels are removed to make it less fuzzy
  geom_node_text(aes(label = id), color = "red")
   
ggraph(mbk3EPnet, x = lon, y = lat) +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
 #the function centtrality_degree() can be called directly as an attribute that will be visualized
   geom_node_point(aes(size = centrality_degree(weights = weight)))
#labels are removed to make it less fuzzy

```

There are other centrality values for nodes. Two that are common too are eigenvector centrality and betweenness centrality. 
Eigenvector centrality also called eigencentrality is based on the influence a node has on the network. The connection to another node with a high centrality score is rated higher than the one to a node with a low score. It can be interpreted as the importance of a node for the network. In an archaeological context it shows not only to how many sites a site is connected, but also how connected those sites are. When weighted the weight of the edges is also taken into account with a similar effect as for degree centrality.
Betweeness centrality is computed by looking at how often a node is passed, when one would (metaphorically) walk from each node in the network to every other node in the network. The node with a high betweenness centrality are those lying on many paths. Typically those nodes are often those with a broker role connecting to subnetworks. The archaeological sites with a high betweenness centrality are those that contain objects from to otherwise more destinctive groups of sites. Betweenness is a difficult score for networks that are based on similarity (as most archaeological networks are), because they tend to form hairballs and there are seldom nodes that are only connected to one other node.
When it is weighted, the pathing sees those edges with a stronger weight as shorter paths and chooses them when calculating the "best" way from node to node. In general, when deciding if weights should be taken into account for centrality, it is always important to wonder if the amount of similarities a connection is based on is important.
```{r eigenvector centrality & betweenness}
 ggraph(mbk3EPnet, layout = "stress") +
 geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
 #the function centrality_eigen() can be called directly as an attribute that will be visualized
   geom_node_point(aes(size = centrality_eigen(weights = weight)))+
#labels are removed to make it less fuzzy
  geom_node_text(aes(label = id), color = "red")
   
ggraph(mbk3EPnet, x = lon, y = lat) +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
 #the function centrality_eigen() can be called directly as an attribute that will be visualized
   geom_node_point(aes(size = centrality_eigen(weights = weight)))
#labels are removed to make it less fuzzy


  ggraph(mbk3EPnet, layout = "stress") +
 geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
 #the function centrality_betweenness() can be called directly as an attribute that will be visualized
   geom_node_point(aes(size = centrality_betweenness(weights = weight)))+
#labels are removed to make it less fuzzy
  geom_node_text(aes(label = id), color = "red")
   
ggraph(mbk3EPnet, x = lon, y = lat) +
#with every layer we add some new part of our network to the plot; first the edges;now the color of the edges is based on there weight. this way we can see which pottery share more than just a single object
    geom_edge_link(aes(color = weight), alpha = 0.5) +
scale_edge_color_continuous(low = "lightblue", high = "red") +
 #the function centrality_betweenness() can be called directly as an attribute that will be visualized
   geom_node_point(aes(size = centrality_betweenness(weights = weight)))
#labels are removed to make it less fuzzy



```

Betweenness can not only be calculated for nodes but also for edges. The process is the same, now the focus is on how many paths an edge lies. If an edge is important for many paths it has a high edge betweenness. Those edges might be the connections between different subgroups.
When weights are taken into account those edges with a stronger weight are often the ones with the hightest betweenness as they are prefered for the pathing.
```{r}
ggraph(mbk3EPnet, layout = "stress") +
#the function edge_betweenness() can be called directly as an attribute that will be visualized; as it is an attribute for edges it is called in the edge layer
   geom_edge_link(aes(color = edge_betweenness(mbk3EPnet, weights = NULL)), alpha = 0.5) +
  scale_edge_color_continuous(low = "lightblue", high = "red") +
   geom_node_point()+  #simple geometry for the edges
  geom_node_text(aes(label = id), color = "red")

ggraph(mbk3EPnet, layout = "stress") +
#the function edge_betweenness() can be called directly as an attribute that will be visualized; as it is an attribute for edges it is called in the edge layer
   geom_edge_link(aes(color = edge_betweenness(mbk3EPnet, weights = weight)), alpha = 0.5) +
  scale_edge_color_continuous(low = "lightblue", high = "red") +
   geom_node_point()+  #simple geometry for the edges
  geom_node_text(aes(label = id), color = "red")

```

